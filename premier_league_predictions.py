# -*- coding: utf-8 -*-
"""premier_league_predictions.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/165N61WbCVIVgJilay5rKpIspH2LWDJlw
"""

import pandas as pd

matches = pd.read_csv('combined_seasons.csv')

matches.head()

matches.shape

matches["team"].value_counts()
# Some teams have gotten promoted or relegated over the years but we are only intereseted in the teams
# in current 2024-2025 season

# Change date type to time
matches["date"] = pd.to_datetime(matches["date"])

matches["venue_cat"]= matches["venue"].astype("category").cat.codes

matches['opp_cat'] = matches['opponent'].astype('category').cat.codes

matches["hour"]= matches["time"].str.replace(":.+", "", regex=True).astype("int")

matches["day_cat"]= matches["date"].dt.dayofweek

#Target is a WIN
matches["target"] = (matches["result"] == "W").astype("int")

from sklearn.ensemble import HistGradientBoostingClassifier
from sklearn.model_selection import GridSearchCV, TimeSeriesSplit
from sklearn.metrics import accuracy_score, precision_score

# Initializing random forest tree model
hg= HistGradientBoostingClassifier()

param_grid = {
    'learning_rate': [0.01, 0.05, 0.1, 0.2, 0.3],
    'max_iter': [100, 200, 500, 1000],
    'max_depth': [3, 5, 7, 9, 12],
    'min_samples_leaf': [1, 2, 5],
    'l2_regularization': [0.0, 0.1, 1.0]
}

tscv = TimeSeriesSplit(n_splits=5)

# GridSearchCV with F1 score
grid_search = GridSearchCV(
    estimator=hg,
    param_grid=param_grid,
    cv=tscv,
    scoring='f1',
    n_jobs=-1,
    verbose=1
)

#training with all matches before the year 2024
train = matches[matches["date"] < '2024-01-01']

test = matches[matches["date"] > '2024-01-01']

predictors = ["venue_cat", "opp_cat", "hour", "day_cat","sh","pk","sot","xg","xga"]

#fit GridSearchCV on the training data
grid_search.fit(train[predictors], train["target"])

print("Best Parameters:", grid_search.best_params_)

#train the best model on the entire training set
best_model = grid_search.best_estimator_

# Make predictions on the test set
preds = best_model.predict(test[predictors])

#model evalutation:
accuracy = accuracy_score(test["target"], preds)
precision = precision_score(test["target"], preds)

print("Test Accuracy:", accuracy)
print("Test Precision:", precision)

#Now creating a new model but with the inlclusion of rolling averages to check the previous form from the past five matches and
# factoring that into the model prediction

#Create one dataframe for each team
grouped_matches = matches.groupby("team")

#Checking their form in the previous matches
def rolling_averages(group, cols, new_cols):
    group = group.sort_values("date")
    #closed left to now include current week
    rolling_stats = group[cols].rolling(3, closed='left').mean()
    group[new_cols] = rolling_stats
    group = group.dropna(subset=new_cols)
    return group

cols = ["gf", "sh", "sot", "pk",]
new_cols = [f"{c}_rolling" for c in cols]

#applying rolling averages to dataframe and adding new column
matches_rolling = matches.groupby("team").apply(lambda x: rolling_averages(x, cols, new_cols))

matches_rolling = matches_rolling.droplevel('team')

#add new indices for the rows
matches_rolling.index = range(matches_rolling.shape[0])

matches_rolling

def make_predictions(data,predictors):
  train = data[data["date"] < '2024-01-01']
  test = data[data["date"] > '2024-01-01']

  #train the best model on the entire training set
  best_model = grid_search.best_estimator_
  #Make predictions on the test set
  preds = best_model.predict(test[predictors])
  #model evalutation:
  accuracy = accuracy_score(test["target"], preds)
  precision = precision_score(test["target"], preds)

  return combined, precision, accuracy

combined, precision , accuracy = make_predictions(matches_rolling, predictors + new_cols)

precision

accuracy

#Fixing team name consistency
# Update map_values to include additional team name variations
map_values = {
    "Sheffield United": "Sheffield Utd",
    "Queens Park Rangers": "QPR",
    "Newcastle United": "Newcastle Utd",
    "West Bromwich Albion": "West Brom",
    "Brighton and Hove Albion": "Brighton",
    "Manchester United": "Manchester Utd",
    "Tottenham Hotspur": "Tottenham",
    "West Ham United": "West Ham",
    "Wolverhampton Wanderers": "Wolves",
    "Nottingham Forest": "Nott' Forest",  # Add Nottingham Forest correction
    # Add more mappings if necessary
}

#define MissingDict class to handle missing keys
class MissingDict(dict):
    __missing__ = lambda self, key: key

mapping = MissingDict(**map_values)

#appply the mapping to correct team names in your DataFrame
matches_rolling['team'] = matches_rolling['team'].map(mapping)
matches_rolling['opponent'] = matches_rolling['opponent'].map(mapping)

combined, precision , accuracy = make_predictions(matches_rolling, predictors + new_cols)

accuracy

precision

