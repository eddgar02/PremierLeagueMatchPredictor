# -*- coding: utf-8 -*-
"""premier_league_predictions.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/165N61WbCVIVgJilay5rKpIspH2LWDJlw
"""

import pandas as pd

matches = pd.read_csv('combined_seasons.csv')

matches.head()

matches.shape

matches["team"].value_counts()
# Some teams have gotten promoted or relegated over the years but we are only intereseted in the teams
# in current 2024-2025 season

matches["round"].value_counts()

# Change date type to time
matches["date"] = pd.to_datetime(matches["date"])

matches["venue_cat"]= matches["venue"].astype("category").cat.codes

matches['opp_cat'] = matches['opponent'].astype('category').cat.codes

matches["hour"]= matches["time"].str.replace(":.+", "", regex=True).astype("int")

matches["day_cat"]= matches["date"].dt.dayofweek

#Target is a WIN
matches["target"] = (matches["result"] == "W").astype("int")

from sklearn.ensemble import HistGradientBoostingClassifier

# Initializing random forest tree model
hg= HistGradientBoostingClassifier()

#Training with all matches before the year 2024
train = matches[matches["date"] < '2024-01-01']

test = matches[matches["date"] > '2024-01-01']

predictors = ["venue_cat", "opp_cat", "hour", "day_cat","sh","pk","sot","xg","xga"]

hg.fit(train[predictors], train["target"])

preds = hg.predict(test[predictors])

from sklearn.metrics import accuracy_score

acc = accuracy_score(test["target"], preds)

acc

#create a dataframe
combined = pd.DataFrame(dict(actual=test["target"], predicted=preds))

pd.crosstab(index=combined["actual"], columns=combined["predicted"])
#

from sklearn.metrics import precision_score

precision_score(test["target"], preds)

#Create one dataframe for each team
grouped_matches = matches.groupby("team")

#Checking their form in the previous matches
def rolling_averages(group, cols, new_cols):
    group = group.sort_values("date")
    #closed left to now include current week
    rolling_stats = group[cols].rolling(3, closed='left').mean()
    group[new_cols] = rolling_stats
    group = group.dropna(subset=new_cols)
    return group

cols = ["gf", "sh", "sot", "pk",]
new_cols = [f"{c}_rolling" for c in cols]

matches_rolling = matches.groupby("team").apply(lambda x: rolling_averages(x, cols, new_cols))

matches_rolling

matches_rolling = matches_rolling.droplevel('team')

#add new indices for the rows
matches_rolling.index = range(matches_rolling.shape[0])

def make_predictions(data,predictors):
  train = data[data["date"] < '2024-01-01']
  test = data[data["date"] > '2024-01-01']
  hg.fit(train[predictors], train["target"])
  preds = hg.predict(test[predictors])
  combined = pd.DataFrame(dict(actual=test["target"], predicted=preds), index=test.index)
  precision = precision_score(test["target"], preds)
  accuracy = accuracy_score(test["target"], preds)
  return combined, precision, accuracy

combined, precision , accuracy = make_predictions(matches_rolling, predictors + new_cols)

precision

accuracy

combined

combined = combined.merge(matches_rolling[["date", "team", "opponent", "result"]], left_index=True, right_index=True)

combined

class MissingDict(dict):
    __missing__ = lambda self, key: key

map_values = {"Sheffield United":"Sheffield Utd","Queens Park Rangers":"QPR","Newcastle United": "Newcastle Utd","West Bromwich Albion": "West Brom","Brighton and Hove Albion": "Brighton", "Manchester United": "Manchester Utd", "Newcastle United": "Newcastle Utd", "Tottenham Hotspur": "Tottenham", "West Ham United": "West Ham", "Wolverhampton Wanderers": "Wolves"}
mapping = MissingDict(**map_values)

mapping["West Ham United"]

combined["new_team"] = combined["team"].map(mapping)

merged = combined.merge(combined, left_on=["date", "new_team"], right_on=["date", "opponent"])

merged

merged[(merged["predicted_x"] == 1) & (merged["predicted_y"] ==0)]["actual_x"].value_counts()

# from looking at the matches in which the algorithm predicted on both sides
# and got .787 precision